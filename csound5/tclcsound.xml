<!--translated=yes
authors=Francois Pinot
english cvs version=1.3
// translated field can be yes, no or partially
// Add your name to the existing list of authors
// Add the version number of the file you are translating from the english version number on cvs
// *** Please remember to keep this information up to date! ***
-->
<chapter id="tclcsound">
<title>TclCsound</title>
<para>
TclCsound fut introduit pour fournir une interface simple de scripting à Csound. Tcl est un langage
simple aisément extensible et qui facilite des opérations comme l'accès aux fichiers et la mise en
réseau sous TCP. Avec son composant Tk, il peut aussi gérer une interface graphique pilotée par
évènements. TclCsound donne trois "points de contact" avec Tcl :</para>
<para>1. un interpréteur tcl connaissant csound (cstclsh) </para>
<para>2. un shell de fenêtrage connaissant csound (cswish) </para>
<para>3. un module de commandes csound pour Tcl/Tk (bibliothèque dynamique tclcsound) </para>

<section id="tclcsh">
<title>L'interpréteur Tcl : cstclsh </title>
<para>Avec cstclsh, on peut contrôler de manière interactive une exécution csound. La commande
  démarre un shell interactif, qui maintient une instance de Csound. On peut ensuite utiliser
  plusieurs commandes pour la contrôler. Par exemple, la commande suivante peut compiler
  du code csound et le charger en mémoire, prêt à être exécuter :</para>
<programlisting>csCompile -odac <emphasis>orchestre</emphasis> <emphasis>partition</emphasis> -m0 </programlisting>
<para>Ceci fait, on peut démarrer l'exécution de deux manières : avec csPlay ou avec csPerform. La
  commande</para>
<programlisting>csPlay </programlisting>
<para>démarrera l'exécution Csound dans un thread séparé et retournera à l'invite de cstclsh. On peut
utiliser ensuite plusieurs commandes pour contrôler Csound. Par exemple,</para>
<programlisting>csPause </programlisting>
<para>suspendra l'exécution ; et</para>
<programlisting>csRewind </programlisting>
<para>reviendra au début de la liste de notes. On peut utiliser les commandes csNote, csTable et 
  csEvent pour ajouter des évènements de partition pendant l'exécution, à la volée. La commande csPerform,
  à l'inverse de csPlay, ne lancera pas un thread séparé, mais démarrera Csound dans le même thread,
  ne retournant que quand l'exécution est finie. Il existe une variété d'autres commandes, donnant un
  contrôle total de Csound.</para>
</section>

<section id="cswish">
<title>Cswish: le shell de fenêtrage</title>
<para>Avec Cswish, on peut utiliser des commandes et des widgets Tk pour se doter
  d'une interface graphique avec gestion d'évènements. Comme pour cstclsh, le lancement de la
  commande cswish ouvre aussi un shell interactif. Par exemple, on peut utiliser les commandes
  suivantes pour créer un panneau de transport pour Csound :</para>
<programlisting>frame .fr
button .fr.play -text play -command csPlay
button .fr.pause -text pause -command csPause
button .fr.rew -text rew -command csRewind
pack .fr .fr.play .fr.pause .fr.rew </programlisting>
<para>De même, on peut lier des touches à des commandes afin d'utiliser le clavier de l'ordinateur
  pour jouer avec Csound.</para>
<para>Les commandes de contrôle de canal fournies par TclCsound sont particulièrement utiles. Par
  exemple, on peut enregistrer des canaux d'E/S nommés avec TclCsound et les utiliser avec les
  opcodes invalue et outvalue. De plus, l'API de Csound fournit aussi un bus logiciel complet pour
  les canaux audio, de contrôle et de chaînes. Dans TclCsound, on peut accéder aux canaux du bus de
  contrôle et de chaînes (le bus audio n'est pas implémenté, car Tcl n'est pas capable de traiter ce
  genre de données). Avec ces commandes de TclCsound, on peut connecter facilement des widgets
  Tk aux paramètres de synthèse.</para>
</section>

<section id="csserver">
<title>Un serveur Csound</title>
<para>Dans Tcl, il est très simple de configurer des connexions réseau TCP. On peut construire un
  serveur csound avec quelques lignes de code. Celui-ci peut accepter des connexions depuis la
  machine locale ou depuis des clients distants. Non seulement les clients Tcl/Tk peuvent lui
  envoyer des commandes, mais des connexions TCP peuvent être établies depuis un autre logiciel,
  comme par exemple, Pure Date (PD). On montre ci-dessous un script Tcl qui peut être lancé dans
  l'interpréteur standard tclsh. Il utilise le module Tclcsound, une bibliothèque dynamique qui
  ajoute les commandes de l'API de Csound à Tcl.</para>
<programlisting>
# load tclcsound.so
#(OSX: tclcsound.dylib, Windows: tclcsound.dll)
load tclcsound.so Tclcsound
set forever 0

# This arranges for commands to be evaluated
proc ChanEval { chan client } {
if { [catch { set rtn [eval [gets $chan]]} err] } {
puts &quot;Error: $err&quot;
} else {
puts $client $rtn
flush $client
}
} 
</programlisting>
<programlisting>
# this arranges for connections to be made 
</programlisting>
<programlisting>
proc NewChan { chan host port } {
puts &quot;Csound server: connected to $host on port $port ($chan)&quot;
fileevent $chan readable [list ChanEval $chan $host]
} 
</programlisting>
<programlisting>
# this sets up a server to listen for
# connections 
</programlisting>
<programlisting>
set server [socket -server NewChan 40001]
set sinfo [fconfigure $server -sockname]
puts &quot;Csound server: ready for connections on port [lindex $sinfo 2]&quot;
vwait forever 
</programlisting>
<para>Lorsque le serveur est actif, il est alors possible de configurer des clients pour contrôler le
  serveur Csound. On peut lancer de tels clients depuis des interpréteurs Tcl/Tk standard, car ils
  n'évaluent pas eux-mêmes les commandes Csound. Voici un exemple de connexions client à un serveur
  Csound au moyen de Tcl :</para>
<programlisting>
# connect to server
set sock [socket localhost 40001]

# compile Csound code
puts $sock &quot;csCompile -odac <emphasis>orchestra</emphasis> <emphasis>score</emphasis>&quot;
flush $sock 
</programlisting>
<programlisting>
# start performance
puts $sock &quot;csPlay&quot;
flush $sock 
</programlisting>
<programlisting>
# stop performance
puts $sock &quot;csStop&quot;
flush $sock 
</programlisting>
<para>Comme il est mentionné ci-dessus, on peut configurer des clients utilisant d'autres systèmes
  logiciels, tels que PD. De tels clients n'ont besoin que de se connecter au serveur (au moyen
  d'un objet netsend) et de lui envoyer des messages. Le premier élément de chaque message est
  une commande. D'autres éléments facultatifs peuvent y être ajoutés comme arguments de cette
  commande.</para>
</section>

<section id="tclscripting">
<title>Un Environnement de scripting</title>
<para>Avec TclCsound, on peut transformer le populaire éditeur de texte emacs en environnement de
  scripting et d'exécution de Csound. Lorqu'il est en mode Tcl, l'éditeur permet d'évaluer des
  expressions Tcl par sélection et utilisation d'une simple séquence d'échappement (Ctrl-C Ctrl-X).
  Grâce à cela, on peut éditer et exécuter du code Csound et Tcl/Tk de façon intégrée</para>
<para>Dans Tcl il est possible d'écrire des fichiers de partition et d'orchestre qui peuvent être
  sauvegardés, compilés et exécutés par le même script, sous l'environnement emacs. L'exemple suivant
  montre un script Tcl qui construit un instrument csound et lance ensuite une exécution de csound.
  Il crée 10 oscillateurs en parallèle légèrement désaccordés, ce qui génère des sons semblables à
  ceux que l'on trouve dans <emphasis>Inharmonique</emphasis> de Risset.</para>
<programlisting>load tclcsound.so Tclcsound </programlisting>
<programlisting># set up some intermediary files </programlisting>
<programlisting>
set orcfile &quot;tcl.orc&quot;
set scofile &quot;tcl.sco&quot;
set orc [open $orcfile w]
set sco [open $scofile w] 
</programlisting>
<programlisting># This Tcl procedure builds an instrument
proc MakeIns { no code } {
global orc sco
puts $orc &quot;instr $no&quot;
puts $orc $code
puts $orc &quot;endin&quot;
} 
</programlisting>
<programlisting>
# Here is the instrument code
append ins &quot;asum init 0 \n&quot;
append ins &quot;ifreq = p5 \n&quot;
append ins &quot;iamp = p4 \n&quot; 
</programlisting>
<programlisting>
for { set i 0 } { $i &lt; 10 } { incr i } {
append ins &quot;a$i oscili iamp,
ifreq+ifreq*[expr $i * 0.002], 1\n&quot;
} 
</programlisting>
<programlisting>for { set i 0 } {$i &lt; 10 } { incr i } {
if { $i } {
append ins &quot; + a$i&quot;
} else {
append ins &quot;asum = a$i &quot;
}
} 
</programlisting>
<programlisting>
append ins &quot;\nk1 linen 1, 0.01, p3, 0.1 \n&quot;
append ins &quot;out asum*k1&quot; 
</programlisting>
<programlisting>
# build the instrument and a dummy score 
</programlisting>
<programlisting>
MakeIns 1 $ins
puts $sco &quot;f0 10&quot;
close $orc
close $sco 
</programlisting>
<programlisting>
# compile
csCompile $orcfile $scofile -odac -d -m0 
</programlisting>
<programlisting>
# set a wavetable
csTable 1 0 16384 10 1 .5 .25 .2 .17 .15 .12 .1 
</programlisting>
<programlisting>
# send in a sequence of events and perform it
for {set i 0} { $i &lt; 60 } { incr i } {
csNote 1 [expr $i * 0.1] .5 \
[expr ($i * 10) + 500] [expr 100 + $i * 10]
}
csPerform 
</programlisting>
<programlisting>
# it is possible to run it interactively as
# well
csNote 1 0 10 1000 200
csPlay 
</programlisting>
<para>De telles facilités comme celles fournies par emacs permettent d'émuler un environnement assez
  proche de ce qu'on trouve dans les soi-disant "systèmes de synthèse modernes", tels que SuperCollider
  (SC). En fait, on peut exécuter Csound dans une configuration client-serveur, ce qui est une des
  fonctionnalités de SC3. Csound a l'avantage majeur de fournir trois ou quatre fois plus de
  générateurs unitaires que ce qu'on trouve dans ce langage (de même qu'il fournit une approche du
  traitement du signal à un plus bas niveau, en fait ce ne sont là que quelques-uns des avantages
  de Csound).</para>
</section>

<section id="tclwrapper">
<title> TclCsound comme encapsuleur de langage</title>
<para>On peut utiliser TclCsound à un niveau légèrement plus bas, car beaucoup des fonctions de
  l'API C ont été encapsulées dans des commandes Tcl. Par exemple, il est possible de créer un
  frontal "classique" pour csound en ligne de commande complètement écrit en Tcl. Le script
  suivant le démontre :</para>
<programlisting>#!/usr/local/bin/cstclsh </programlisting>
<programlisting>
set result 1
csCompileList $argv
while { $result != 0 } {
set result csPerformKsmps
}
</programlisting>
</section>

<section id="tclrefe">
<title>Référence des commandes de TclCsound</title>

<para>Commandes de contrôle de l'exécution :</para>
<para> <command> 
csCompile [ligne de commande csound] : </command> compile un orc/sco/csd + des options 
</para> <para> <command> 
csCompileList arglist : </command> compile un orc/sco/csd + des options, donnés comme une liste Tcl 'arglist'
</para> <para> <command> 
csPerform : </command> joue la partition, retournant à la fin
</para> <para> <command> 
csPerformKsmps : </command> exécute un bloc de ksmps échantillons audio, puis retourne
</para> <para> <command> 
csPerformBuffer : </command> exécute un bloc d'échantillons audio de la taille d'un tampon, puis retourne
</para> <para> <command> 
csPlay : </command> démarre une exécution asynchrone dans un thread séparé, retournant immédiatement
</para> <para> <command> 
csPause : </command> suspend la reproduction
</para> <para> <command> 
csStop : </command> arrête l'exécution et réinitialise csound
</para> <para> <command> 
csRewind : </command> repositionne la partition au début
</para> <para> <command> 
csOffset secs : </command> décale le point de reproduction dans la partition de 'secs' secondes
</para> <para> <command> 
csGetoffset : </command> retourne le point de décalage dans la partition en secondes
</para> <para> <command> 
csGetScoreTime : </command> retourne le temps de la partition en secondes
</para>

<para>Commandes d'évènements :</para>
<para> <command> csNote [p-champs] : </command> envoie un évènement dans une instruction i
</para> <para> <command> csTable [p-champs] : </command> envoie un évènement dans une instruction f
</para> <para> <command> csEvent opcode [p-champs] : </command> envoie un évènement de partition défini par 'opcode' plus les p-champs
</para> <para> <command> csNoteList arglist : </command> envoie un évènement dans une instruction i avec les p-champs dans une liste Tcl 'arglist'
</para> <para> <command> csTableList arglist : </command> envoie un évènement dans une instruction f avec les p-champs dans une liste Tcl 'arglist'
</para> <para> <command> csEventList arglist : </command> envoie un évènement de partition défini par 'opcode' avec les p-champs dans une liste Tcl 'arglist'
</para>

<para>Commandes de canal de contrôle et de chaîne, invalue, outvalue, pvsin, pvsout :</para>
<para> <command> csInChannel nom : </command> enregistre un canal csound invalue 
</para> <para> <command> csOutChannel nom : </command> enregistre un canal csound outvalue et crée la variable tcl globale 'nom'
</para> <para> <command> csInValue canal valeur : </command> fixe une valeur sur un canal csound invalue
</para> <para> <command> csOutValue canal : </command> retourne la valeur d'un canal csound outvalue
</para> <para> <command> csPvsIn number [size olaps wsize wtype] : </command> enregistre un canal du bus d'entrée pvs, initialisant optionnellement
  les valeurs de fsig à une taille de tfr de 'size' (par défaut : 1024), une taille de chevauchement de 'olaps' (par défaut : size/4), une taille de
  fenêtre de 'wsize' (par défaut : size) et le type de fenêtre à 'wtype' (par défaut : 1, fenêtre de Hanning, voir la page de manuel pour pvsanal).
  Fonctionne avec l'opcode pvsin (seulement le format PVS_AMP_FREQ).
</para> <para> <command> csPvsOut number [size olaps wsize wtype] : </command> enregistre un canal du bus de sortie pvs. Fonctionne avec
  l'opcode pvsout (seulement le format PVS_AMP_FREQ).
</para> <para> <command> csPvsInSet channel bin amp freq : </command> fixe l'amplitude et la fréquence d'un bin du canal d'entrée pvs 'channel'.
</para> <para> <command> csPvsOutGet channel bin [isFreq] : </command> retourne l'amplitude ou la fréquence d'un bin du canal de sortie pvs 'channel'.
  L'argument optionnel 'isFreq' (par défaut : 0) contrôle si la valeur retournée est l'amplitude du bin (0) ou sa fréquence (1).
</para> <para> <command> csSetControlChannel channel value : </command> fixe la valeur du canal de contrôle 'channel', le créant s'il n'existe pas.
</para> <para> <command> csGetControlChannel channel : </command> retourne la valeur du canal de contrôle 'channel', le créant s'il n'existe pas.
</para> <para> <command> csSetStringChannel channel string : </command> fixe la chaîne dans le canal 'channel', le créant s'il n'existe pas.
</para> <para> <command> csGetStringChannel channel : </command> retourne la chaîne qui est dans le canal 'channel', le créant s'il n'existe pas.
</para>

<para>Commandes de message : </para>
<para> <command>csMessageOutput  var : </command>ajoute tous les messages csound à la variable tcl 'var'.</para>

<para>Commandes de table :</para>
<para> <command> csGetTableSize ftn : </command> retourne la taille de la table de fonction ftn (-1 si elle n'existe pas).
</para> <para> <command> csSetTable ftn index value : </command> fixe la valeur de la position 'index' dans la table de fonction 'ftn' à 'value'.
</para> <para> <command> csGetTable ftn index : </command> retourne la valeur de la position 'index' dans la table de fonction 'ftn'.
</para>

<para>Commandes de variable d'environnement :
</para>
<para> <command> csOpcodedir opcodedir : </command> fixe le répertoire des opcode.
</para> <para> <command> csSetenv envvar value : </command> fixe la valeur d'une variable d'environnement (par exemple SFDIR, SADIR). 
</para>
</section>
</chapter>

