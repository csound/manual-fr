<!--translated=yes
authors=Francois Pinot
english cvs version=
// translated field can be yes, no or partially
// Add your name to the existing list of authors
// Add the version number of the file you are translating from the english version number on cvs
// *** Please remember to keep this information up to date! ***
-->

<refentry id="lua_opdef">
  <indexterm id="Indexlua_opdef"><primary>lua_opdef</primary></indexterm>
  <refentryinfo><title>Lua Opcodes</title></refentryinfo>
  <refmeta>
    <refentrytitle>lua_opdef</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>lua_opdef</refname>
    <refpurpose>
      Définit un opcode dans Lua durant l'initialisation. L'opcode peut prendre
      n'importe quel nombre d'arguments de sortie et/ou d'entrée, de n'importe
      quel type.
    </refpurpose>
  </refnamediv>

  <refsect1>
    <title>
      Description
    </title>
    <para>Opcode de greffon dans LuaCsound.</para>
    <para>
      Définit un opcode en Lua durant l'initialisation. L'opcode peut prendre
      n'importe quel nombre d'arguments de sortie et/ou d'entrée, de n'importe
      quel type. Le code est exécuté durant l'initialisation, typiquement depuis
      l'en-tête de l'orchestre.  On peut déclarer et définir des variables
      globales et locales, des fonctions, des tables et des classes. Les objets
      définis dans la portée globale de Lua restent accessibles durant toute
      l'exécution, et ils sont visibles depuis tout autre code Lua situé dans
      le même fil de Csound.
    </para>
    <note>
      <para>
        Par défaut, tous les objets définis dans Lua sont dans la portée globale.
        Pour maintenir les objets confinés dans leur propre bloc de code,
        c'est-à-dire pour que les objets ne soient visibles que dans leur portée
        lexicale, il faut les déclarer avec l'attribut <emphasis>local</emphasis>.
        Cette particularité de Lua a souvent tendance à troubler les débutants.
      </para> 
      <para>
        Il faut aussi tenir compte du fait que les tableaux de Lua sont indexés
        à partir de 1 à l'inverse de ceux de C et d'autres langages de programmation
        qui sont indéxés à partir de 0.
      </para>
    </note>
  </refsect1>

  <refsect1>
    <title>Syntaxe</title>
    <synopsis><command>lua_opdef</command> Sname, Sluacode</synopsis>
  </refsect1>

  <refsect1>
    <title>
      Initialisation
    </title>
    <para>
      <emphasis>Sname</emphasis> -- Le nom de l'opcode.
    </para>
    <para>
      <emphasis>Sluacode</emphasis> -- Un bloc de code Lua, de n'importe quelle
      longueur. On peut entourer les blocs multi-lignes par des accolades
      doubles (<literal>{{ }}</literal>). Le code est évalué une seule fois
      durant l'initialisation.  
    </para>
    <para>
      Le code Lua doit définir toutes les fonctions qui seront appelées depuis
      Csound, en utilisant les conventions de nommage suivantes où
      <emphasis>opcodename</emphasis> doit être remplacé par le nom choisi pour
      l'opcode :
    </para>    
    <itemizedlist>
      <listitem><simpara>
        <literal>opcodename_init</literal> pour le sous-programme de l'opcode
        de taux-i.
      </simpara></listitem>
      <listitem><simpara>
        <literal>opcodename_kontrol</literal> pour le sous-programme de l'opcode
        de taux-k.
      </simpara></listitem>
      <listitem><simpara>
        <literal>opcodename_audio</literal> pour le sous-programme de l'opcode
        de taux-a.
      </simpara></listitem>
      <listitem><simpara>
        <literal>opcodename_noteoff</literal> pour le sous-programme de fin de
        note.
      </simpara></listitem>
    </itemizedlist>
    <para>
      Chacune de ces fonctions Lua recevra trois arguments légers (pointeurs) :
      l'objet CSOUND, l'instance de l'opcode et un pointeur vers les arguments
      de l'opcode, dont le code Lua doit convertir le type en celui d'une
      structure ctype de LuaJIT FFI contenant les arguments de sortie, d'entrée
      et les variables d'état de l'opcode. En utilisant, LuaJIT FFI, les éléments
      de cette structure seront accessibles comme s'ils étaient des types de Lua.
    </para>
    <para>
      Chacune de ces fonctions Lua doit retourner 0 en cas de succès et 1 en cas
      d'échec.
    </para>
    <para>
      Les fonctions Lua peuvent faire absolument tout ce que l'on veut, tout en
      sachant que si l'on désire une exécution en temps réel, il faut prendre soin
      de désactiver le ramasse-miettes de Lua et observer d'autres recommandations
      pour le code en temps réel.
    </para>
  </refsect1>

  <refsect1>
    <!--To add examples, create the csd file in the examples directory, then run:-->
    <!--python csd2docbook.py -f newopcodename.csd-->
    <!--to generate the xml highlighted version used below-->
    <title>Exemple</title>
    <para>
      Voici un exemple d'opcode Lua, implémentant un filtre en échelle de Moog.
      Afin de pouvoir les comparer, un opcode défini par l'utilisateur et l'opcode
      natif de Csound produisant les mêmes sonorités avec le même algorithme
      sont également montrés et chronométrés... L'exemple utilise le fichier
      <ulink url="examples/luamoog.csd"><citetitle>luamoog.csd</citetitle></ulink>.
      <example>
        <title>
          Exemple d'opcode Lua.
        </title>
        <xi:include href="examples-xml/luamoog.csd.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
      </example>
    </para>
  </refsect1>

  <refsect1>
    <title>Voir aussi</title>
    <para>
      <link linkend="lua_exec"><citetitle>lua_exec</citetitle></link>, 
      <link linkend="lua_opcall"><citetitle>lua_opcall</citetitle></link>. 
    </para>
  </refsect1>
  
  <refsect1>
    <title>Crédits</title>
    <para>
      Par : &namemichael;, 2011
    </para>
    <para>
      Nouveau dans la version 5.13.2 de Csound.
    </para>
  </refsect1>
</refentry>
