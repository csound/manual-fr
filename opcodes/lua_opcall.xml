<!--translated=yes
authors=Francois Pinot
english cvs version=
// translated field can be yes, no or partially
// Add your name to the existing list of authors
// Add the version number of the file you are translating from the english version number on cvs
// *** Please remember to keep this information up to date! ***
-->

 <refentry id="lua_opcall">
  <indexterm id="Indexlua_opcall"><primary>lua_opcall</primary></indexterm>
  <refentryinfo><title>Lua Opcodes</title></refentryinfo>
  <refmeta>
    <refentrytitle>lua_opcall</refentrytitle>
  </refmeta>

  <refnamediv>
    <refname>lua_opcall</refname>
    <refpurpose>
      Appelle un opcode Lua. N'importe quel nombre d'argument d'entrée et/ou de
      sortie peuvent être passés. Tous les arguments doivent être écrits du
      côté droit. Les sorties sont retournées dans les arguments.
    </refpurpose>
  </refnamediv>
  
  <refsect1>
    <title>Syntaxe</title>
    <synopsis><command>lua_iopcall</command> Sname, ...</synopsis>
    <synopsis><command>lua_ikopcall</command> Sname, ...</synopsis>
    <synopsis><command>lua_iaopcall</command> Sname, ...</synopsis>
    <synopsis><command>lua_iopcall_off</command> Sname, ...</synopsis>
    <synopsis><command>lua_ikopcall_off</command> Sname, ...</synopsis>
    <synopsis><command>lua_iaopcall_off</command> Sname, ...</synopsis>
  </refsect1>

  <refsect1>
    <title>Initialisation et Exécution</title>
    <para>
      <emphasis>Sname</emphasis> -- Le nom de l'opcode.
    </para>
    <para>
      <emphasis>...</emphasis> -- Une liste arbitraire de n'importe quel nombre
      d'arguments de sortie et d'entrée, de n'importe quel type. Le nombre,
      l'ordre et les types de ces arguments doivent se conformer au cdef de la
      structure des arguments qui est déclarée dans l'opcode
      <literal>lua_opdef</literal> correspondant.
    </para>
    <para>
      <literal>lua_iopcall</literal> appelle un opcode Lua au taux-i. Il faut
      que <literal>opname_init</literal> soit défini en Lua.
    </para>
      <literal>lua_ikopcall</literal> appelle un opcode Lua au taux-i et au taux-k.
      Il faut que <literal>opname_init</literal> et
      <literal>opname_kontrol</literal> soient définis en Lua.
    <para>
      <literal>lua_iaopcall</literal> appelle un opcode Lua au taux-i et au taux-a.
      Il faut que <literal>opname_init</literal> et
      <literal>opname_audio</literal> soient définis en Lua.
    </para>
    <para>
      <literal>lua_iopcall_off</literal> appelle un opcode Lua de fin de note au
      taux-i. Il faut que <literal>opname_init</literal> et
      <literal>opname_noteoff</literal> soient définis en Lua.
    </para>
      <literal>lua_ikopcall_off</literal> appelle un opcode Lua de fin de note au
      taux-i et au taux-k. Il faut que <literal>opname_init</literal>,
      <literal>opname_kontrol</literal> et <literal>opname_noteoff</literal>
      soient définis en Lua.
    <para>
      <literal>lua_iaopcall_off</literal> appelle un opcode Lua de fin de note au
      taux-i et au taux-a. Il faut que <literal>opname_init</literal>,
      <literal>opname_audio</literal> et <literal>opname_noteoff</literal>
      soient définis en Lua.
    </para>
    <para>
      Le code Lua accède aux éléments des arguments comme suit (les pointeurs
      vers les scalaires et vers les tableaux sont déréférencés par l'opérateur
      Lua d'accès aux tableaux) :
    </para>
    <programlisting>
      ffi.cdef(' struct arguments_t { double *a_out, double *i_in, double *i_txt, double *f_sig };');
      local arguments = ffi.cast("struct arguments_t *", carguments_lightuserdata)
      for i = 0, ksmps -1 do begin carguments.a_out[i] = carguments.i_in[0] * 3 end end
    </programlisting>
    <para>
      La variante "off" des opcodes programme toujours un évènement de fin de
      note qui est appelé lorsque l'instance de l'instrument est retirée de la
      liste active, et qui peut être utilisé pour libérer des ressources dont
      on a plus besoin, reprogrammer l'instrument pour restituer une queue de
      réverbération, etc.
    </para>
  </refsect1>

  <refsect1>
    <!--To add examples, create the csd file in the examples directory, then run:-->
    <!--python csd2docbook.py -f newopcodename.csd-->
    <!--to generate the xml highlighted version used below-->
    <title>Exemple</title>
    <para>
      Voici un exemple d'opcode Lua, montrant comment transmettre dans les deux
      sens des chaînes de caractères entre le code des opcodes Lua et celui de
      l'orchestre de Csound. L'exemple utilise le fichier
      <ulink url="examples/luaopcode.csd"><citetitle>luaopcode.csd</citetitle></ulink>.
      <example>
        <title>
          Exemple d'opcode Lua.
        </title>
        <xi:include href="examples-xml/luaopcode.csd.xml" xmlns:xi="http://www.w3.org/2001/XInclude"/>
      </example>
    </para>
  </refsect1>
  
  <refsect1>
    <title>Voir aussi</title>
    <para>
      <link linkend="lua_exec"><citetitle>lua_exec</citetitle></link>, 
      <link linkend="lua_opdef"><citetitle>lua_opdef</citetitle></link>. 
    </para>
  </refsect1>
  
  <refsect1>
    <title>Crédits</title>
    <para>
      Par : &namemichael;, 2011
    </para>
    <para>
      Nouveau dans la version 5.13.2 de Csound.
    </para>
  </refsect1>
</refentry>
